/**
 * Generates custom-styled radio options wrapped in structured HTML.
 *
 * Each option is rendered as a custom block with optional icons and toggle visuals.
 * Only one option can be selected at a time. If multiple options are marked as selected,
 * only the first will be retained.
 *
 * If either `label` or `value` is missing in an option, the other will be used as a fallback.
 * An error is thrown if both are missing.
 *
 * @param {string} name - The name of the radio group. Used as the name attribute of the hidden input.
 * @param {Array<Object>} options - Array of option objects for each radio choice.
 * @param {string} [options[].label] - The display label for the radio option. Used as fallback for value if value is not provided.
 * @param {string} [options[].value] - The value for the option. Used as fallback for label if label is not provided.
 * @param {string} [options[].icon] - Optional icon class to display (e.g., FontAwesome class).
 * @param {boolean} [options[].selected=false] - Whether the option is selected by default.
 * @param {Array<{name: string, value: string}>} [options[].attributes] - Additional HTML attributes for the option container.
 * @param {Object} [attributes={}] - Additional HTML attributes for the outer `_form_group` container.
 * @returns {string} - HTML markup representing the custom radio option group.
 */
export function generateRadioOptions(name, options = [], attributes = {}) {
    const containerAttributes = {
        class: '_form_group',
        ...attributes
    };

    let selectedFound = false;
    options.forEach(option => {
        if (option.selected && selectedFound) {
            option.selected = false;
        }
        if (option.selected) {
            selectedFound = true;
        }

        if (!option.label && !option.value) {
            throw new Error("Each option must have at least a 'label' or 'value'");
        }

        if (!option.label) {
            option.label = option.value;
        }

        if (!option.value) {
            option.value = option.label;
        }
    });

    let output = `<div ${generateAttributes(containerAttributes)}>`;
    output += `<div class="_radio_options" data-radio_options_name="${name}">`;

    options.forEach(option => {
        const { label, value, icon, attributes: optionAttributes = [], selected = false } = option;

        const defaultOptionAttributes = {
            class: `_radio_option ${selected ? '_selected' : ''}`,
            'data-radio_option_value': value
        };

        const optionAttrs = {
            ...defaultOptionAttributes,
            ...optionAttributes.reduce((acc, { name, value }) => {
                acc[name] = value;
                return acc;
            }, {})
        };

        output += `
            <div ${generateAttributes(optionAttrs)}>
                <div class="_radio_option_label">
                    ${icon ? `<i class="${icon}"></i>` : ''}
                    <span>${label}</span>
                </div>
                <div class="_radio_option_toggle"><span></span></div>
            </div>
        `;
    });

    output += `<input type="hidden" class="_radio_options_value" name="${name}" value="${options.find(option => option.selected)?.value || options[0].value}" required>`;
    output += '</div></div>';
    return output;
}

/**
 * Converts an object of key-value pairs into a string of HTML attributes.
 *
 * @param {Object} attributes - An object representing HTML attributes (e.g., { class: "my-class", id: "main" }).
 * @returns {string} - A space-separated string of HTML attributes.
 */
function generateAttributes(attributes) {
    return Object.entries(attributes)
        .map(([key, value]) => `${key}="${value}"`)
        .join(' ');
}

/**
 * Initializes click behavior for custom-styled radio options.
 *
 * When an option is clicked:
 * - All other options are deselected (`_selected` class removed).
 * - The clicked option is marked as selected (`_selected` class added).
 * - The associated hidden input is updated with the selected value.
 *
 * This logic assumes the structure generated by `generateRadioOptions()`,
 * where each group has a `. _radio_options` container and a hidden input
 * named `._radio_options_value`.
 */
document.addEventListener("DOMContentLoaded", function () {
    document.addEventListener("click", function (e) {
        const option = e.target.closest("._radio_option");
        if (!option) return;

        const optionsContainer = option.closest("._radio_options");
        const radioOptionsInput = optionsContainer.querySelector("._radio_options_value");

        // Deselect all options
        optionsContainer.querySelectorAll("._radio_option").forEach(opt => {
            opt.classList.remove("_selected");
        });

        // Select clicked option
        option.classList.add("_selected");

        // Update hidden input value
        radioOptionsInput.value = option.getAttribute("data-radio_option_value");
    });
});

export const lcsRadioSelectionEvent = true;